

import marimo

__generated_with = "0.13.0"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell
def _():
    import pandas as pd
    return (pd,)


@app.cell
def _(pd):
    df = pd.read_csv("C:/Users/pappi/OneDrive/Bureaublad/Lessen/Data Visualisation/tdf_stages.csv")
    return (df,)


@app.cell
def _(df):
    df
    return


@app.cell
def _(mo):
    # Create a slider for selecting the year using correct parameter names
    year_slider = mo.ui.slider(1903, 2017)
    return (year_slider,)


@app.cell
def _(df, pd):
    df["Date"] = pd.to_datetime(df["Date"])  # Convert to datetime format
    return


@app.cell
def _(df, mo, year_slider):
    import geopandas as gpd
    import matplotlib.pyplot as plt
    import plotly.express as px


    # Load the world shapefile
    shapefile_path = "C:/Users/pappi/OneDrive/Bureaublad/Lessen/Data Visualisation/ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp"
    world = gpd.read_file(shapefile_path)

    # Rename column if needed
    if "ADM0_A3" in world.columns:
        world = world.rename(columns={"ADM0_A3": "iso_a3"})



    selected_year = year_slider.value  # The reactive value for filtering

    # Filter for the selected year and count occurrences of Winner_Country
    df_year = df[df["Date"].dt.year == selected_year]
    country_counts = df_year["Winner_Country"].value_counts().reset_index()
    country_counts.columns = ["iso_a3", "count"]

    # Merge occurrence counts with the world GeoDataFrame and fill missing counts with 0
    world = world.merge(country_counts, on="iso_a3", how="left")
    world["count"] = world["count"].fillna(0)

    # Filter for European countries (assuming a 'CONTINENT' column exists)
    europe = world[world["CONTINENT"] == "Europe"]

    # Create a figure with two subplots: one for the world map, one for zoomed-in continental Europe
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(24, 6))

    # Plot world map with occurrence counts
    world.plot(column="count", cmap="Blues", linewidth=0.8,
               edgecolor="black", legend=True, ax=ax1)
    ax1.set_title(f"Stage winners in ({selected_year}) - World", fontsize=14)

    # Plot continental Europe (zoomed in) with occurrence counts
    europe.plot(column="count", cmap="Greens", linewidth=0.8,
                edgecolor="black", legend=True, ax=ax2)
    ax2.set_title(f"Stage winners in ({selected_year}) - Continental Europe", fontsize=14)
    ax2.set_xlim(-25, 45)
    ax2.set_ylim(34, 72)
    ax2.set_aspect('equal')

    plt.tight_layout()

    import base64
    import io


    # (Your plotting code here; assume `fig` is your Matplotlib figure)
    # For example:
    # fig, ax = plt.subplots()
    # ax.plot([1, 2, 3], [4, 5, 6])
    # ax.set_title("My Plot")

    # Save the figure into an in-memory buffer in PNG format
    buf = io.BytesIO()
    fig.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)

    # Encode the PNG image to a base64 string
    img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')

    # Create an HTML snippet that embeds the image
    html_code = f"""
      <img src="data:image/png;base64,{img_base64}" 
           alt="Plot" 
           style="max-width: 100%; height: auto;" />
    """

    # Use the HTML widget to display the image alongside your slider.
    # (Check your version of Marimo whether a function like mo.ui.html is available.)
    mo.vstack([mo.md(f"Nationality of stage winners in {selected_year}"), year_slider, mo.Html(html_code)])
    return


if __name__ == "__main__":
    app.run()
